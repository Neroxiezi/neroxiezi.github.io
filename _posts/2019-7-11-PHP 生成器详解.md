---
layout: post
title:  "PHP 生成器详解"
date:   2019-7-11 10:00:02 +0800
author: "南丞"
desc: "PHP 大杀器之生成器"

in_head: "<style> .article-content p{
  text-indent: 2em;
  line-height: 1.75rem;
}</style>"
---

### PHP 生成器详解

生成器和迭代器有点类似，但是与标准的PHP迭代器不同，PHP生成器不要求类实现Iterator接口，从而减轻了类的开销和负担。生成器会根据需求每次计算并产出需要迭代的值，这对应用的性能有很大的影响：试想假如标准的PHP迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低下；如果要使用特定方式计算大量数据，如操作Excel表数据，对性能影响更甚。此时我们可以使用生成器，即时计算并产出后续值，不占用宝贵的内存空间。

生成器也是一个函数,不同的是这个函数的返回值是依次返回,而不是只返回一个单独的值.或者,换句话说,生成器使你能更方便的实现了迭代器接口.

### 实例1:

```php
function crange($number){
    $data = [];
    for($i=0;$i<$number;$i++){
        $data[] = time();
    }
    return $data;
}
```
上面是一个普通的生成数组的函数,我们调用 *crange(10)* 也是正常,但是如果我们传递的参数是*crange(10000000)*的时候就会发现,如下:

![](/images/y_error.png)

内存崩了,解决这个问题,优化一下:

```php
    function crange($number){
        for($i=0;$i<$number;$i++){
            yield $i;
        }
    }
```
如上代码所示,使用关键字 *yield*。

```php
  $data = crange(10000000);
  //var_dump($data);  在调用函数的时候 就会返回一个 Generator 的对象
  //用foreach进行遍历，每次遍历都会隐式调用current()、next()、key()、valid()等方法。（Generator类中的方法）
  foreach($data as $num) {
      var_dump($num);
  }
```
上面函数毫无压力的打印出结果，因为生成器每次只需要为一个整数分配内存。

### 实例2:

```php
//生成一个键值对
$input = <<<EOF
1;PHP-全世界最好的语言
2;Python-这个没得说了
3;Ruby-我不认识他
EOF;
function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);
        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
}
```

### 实例3：

```php
//生成一个指定元素个数的
function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>

```



